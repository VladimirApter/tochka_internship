# Описание решения

Идея решения в том, чтобы не перебирать все возможные пути по всей карте, а сильно сократить перебор изначально выбрав 
кратчайшие расстояния между важными точками. Для этого сначала строится так называемый сжатый граф, в котором 
учитываются только важные точки - это стартовые позиции роботов и клетки где лежат ключи. Остальные клетки не важны 
сами по себе, они нужны только для того, чтобы посчитать расстояния между важными точками.
Как мы строим этот сжатый граф? Из каждой важной точки запускаем обход в ширину. Когда находим другую важную 
точку, мы запоминаем расстояние до неё и какие двери встретили на этом пути. Эти данные сохраняем как ребро между двумя 
точками в сжатом графе. Благодаря этому мы заранее знаем какие ключи нужны, чтобы попасть из одной важной точки в 
другую и сколько шагов это займёт.

Дальше мы работаем с графом состояний. Каждое состояние - это набор, который описывает где сейчас находятся все 
четыре робота и какие ключи уже собраны. Из этих состояний мы ищем кратчайший путь к тому состоянию, где собраны все 
ключи. Для этого используем алгоритм Дейкстры. Мы начинаем из состояния, где роботы стоят на старте и у нас нет ни 
одного ключа. Затем постепенно перебираем возможные ходы: двигаем одного из роботов в какую-то важную точку если можем 
туда попасть (то есть если у нас уже есть нужные ключи для открывания дверей). Так продолжаем пока не найдём состояние
в котором у нас есть все ключи - это и будет минимальное количество шагов.

Чтобы ускорить проверки какие ключи уже собраны и какие нужны для прохода используется битовая маска. Набор ключей и 
дверей представляется обычным целым числом, где каждый бит показывает наличие ключа.
Позиции роботов тоже хранятся компактно - в одном числе с помощью битов. А чтобы не считать лишние состояния мы 
сортируем позиции роботов. Ведь если поменять местами двух роботов, но они стоят в тех же клетках и у нас те же ключи - 
это эквивалентное состояние и второй раз его рассматривать не нужно.

И ещё один момент: в версии C#, которая указана в шаблоне (Mono 6.6) нет очереди с приоритетами. Поэтому в коде я 
использую свою реализацию MinHeap для алгоритма Дейкстры.
